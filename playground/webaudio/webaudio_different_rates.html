<html>
  <head>
    <title>WebAudio Different Sample Rates Test</title>
  </head>
  <script>
    function createSineWaveInput(rate, frequency = 440) {
      const ctx = new AudioContext({ sampleRate: rate });
      const osc = ctx.createOscillator();
      osc.type = "sine";
      osc.frequency.value = frequency;
      const dest = new MediaStreamAudioDestinationNode(ctx);
      osc.connect(dest);
      return { ctx, osc, dest };
    }

    async function createAudioSourceAndSilenceDetector(rate, stream) {
      const ctx = new AudioContext({ sampleRate: rate });
      await ctx.audioWorklet.addModule("silence-detector.js");
      const sourceNode = ctx.createMediaStreamSource(stream);
      const detectorNode = new AudioWorkletNode(ctx, "silence-detector");
      sourceNode.connect(detectorNode);
      detectorNode.connect(ctx.destination);
      return { ctx, sourceNode, detectorNode };
    }

    async function waitForMessage(detectorNode, timeoutMs = 5000) {
      return new Promise((resolve, reject) => {
        // If the node's context is closed, resolve immediately.
        if (detectorNode.context.state === "closed") {
          return reject(
            new Error(
              `Detector at rate ${detectorNode.context.sampleRate} is closed.`
            )
          );
        }

        const timeoutId = setTimeout(() => {
          detectorNode.port.onmessage = originalOnMessage;
          reject(
            new Error(
              `Timed out waiting for message from detector at rate ${detectorNode.context.sampleRate}.`
            )
          );
        }, timeoutMs);

        detectorNode.port.onmessage = (event) => {
          clearTimeout(timeoutId);
          // Clear the handler after receiving a message.
          detectorNode.port.onmessage = null;
          resolve(event.data);
        };
      });
    }

    function assert(condition, message) {
      if (!condition) {
        console.error(message || "Assertion failed");
      }
    }

    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    // Returns the max buffer processing delay (ms) for given analysers.
    function calculateRequiredDelay(nodes, safetyMarginMs = 300) {
      if (!nodes || nodes.length === 0) {
        return 0;
      }

      // Each buffer processing takes processingBlockSize / sampleRate seconds.
      // The default block size is 128 samples.
      const processingBlockSize = 128;
      const maxDurationSec = Math.max(
        ...nodes.map((n) => processingBlockSize / n.context.sampleRate)
      );

      return maxDurationSec * 1000 + safetyMarginMs;
    }

    async function testClosingOneContextStopsOnlyIt(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test closing one context stops only it: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Ensure closing one sourceNode's context stops it without affecting others.

      for (const { detectorNode } of pairs) {
        detectorNode.port.onmessage = (event) => {
          detectorNode.isSilent = event.data.isSilent;
        };
      }

      console.log("Closing the context for the first detector...");
      const ctxToClose = pairs[0].ctx;
      await ctxToClose.close();

      console.assert(
        ctxToClose.state === "closed",
        "Context should be closed."
      );

      await delay(
        calculateRequiredDelay(pairs.slice(1).map((p) => p.detectorNode))
      );

      // Verify the other detectors are still active.
      for (const { detectorNode } of pairs.slice(1)) {
        assert(
          !detectorNode.isSilent,
          `Detector in context with rate ${detectorNode.context.sampleRate} should not be silent after another context was closed.`
        );
      }

      // Clean up remaining contexts.
      for (const { ctx } of pairs.slice(1)) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testSuspendingOneContextSilencesOnlyIt(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test suspending one context silences only it: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that suspending one context silences its detector without impacting others.

      for (const { detectorNode } of pairs) {
        detectorNode.port.onmessage = (event) => {
          detectorNode.isSilent = event.data.isSilent;
        };
      }

      console.log("Suspending the first context...");
      await pairs[0].ctx.suspend();

      await delay(
        calculateRequiredDelay(pairs.slice(1).map((p) => p.detectorNode))
      );

      // Verify the other active detectors are still running.
      for (const { detectorNode } of pairs.slice(1)) {
        assert(
          !detectorNode.isSilent,
          `Detector in context with rate ${detectorNode.context.sampleRate} should not be silent after another context was suspended.`
        );
      }

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testDisconnectingOneSourceSilencesOnlyIt(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test disconnecting one source silences only it: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that disconnecting one source node silences its detector without impacting others.

      for (const { detectorNode } of pairs) {
        detectorNode.port.onmessage = (event) => {
          detectorNode.isSilent = event.data.isSilent;
        };
      }

      console.log("Disconnecting the source node for the first detector...");
      const sourceNodeToDisconnect = pairs[0].sourceNode;
      sourceNodeToDisconnect.disconnect();

      await delay(
        calculateRequiredDelay(pairs.slice(1).map((p) => p.detectorNode))
      );

      // Verify the other active detectors are still running.
      for (const { detectorNode } of pairs.slice(1)) {
        assert(
          !detectorNode.isSilent,
          `Detector in context with rate ${detectorNode.context.sampleRate} should not be silent after another source was disconnected.`
        );
      }

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testStoppingOneMediaStream(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test stopping one MediaStream silences ${
          cloneTracks ? "only it" : "all"
        }: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that stopping the tracks of one MediaStream silences only its detector or all of them.

      for (let i = 1; i < pairs.length; i++) {
        const { detectorNode } = pairs[i];
        detectorNode.port.onmessage = (event) => {
          detectorNode.isSilent = event.data.isSilent;
        };
      }
      let msgPromise = waitForMessage(pairs[0].detectorNode);

      console.log("Stopping the tracks for the first detector's stream...");
      const streamToStop = pairs[0].sourceNode.mediaStream;
      streamToStop.getTracks().forEach((track) => track.stop());

      let msg = await msgPromise;
      assert(
        msg.isSilent,
        `Detector in context with rate ${pairs[0].detectorNode.context.sampleRate} should be silent after its stream tracks were stopped.`
      );
      pairs[0].detectorNode.isSilent = msg.isSilent;

      await delay(
        calculateRequiredDelay(pairs.slice(1).map((p) => p.detectorNode))
      );

      // If MediaStreamTracks are shared across contexts, all detectors should be silent.
      // Otherwise, only the one with the stopped stream should be silent.
      for (let i = 1; i < pairs.length; i++) {
        const { detectorNode } = pairs[i];
        const expectedSilent = !cloneTracks;
        assert(
          detectorNode.isSilent === expectedSilent,
          `Detector in context with rate ${detectorNode.context.sampleRate} expected isSilent=${expectedSilent}, but got isSilent=${detectorNode.isSilent}.`
        );
      }

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testDisablingOneMediaStream(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test disabling one MediaStream silences ${
          cloneTracks ? "only it" : "all"
        }: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that disabling the tracks of one MediaStream silences only its detector or all of them.

      for (let i = 1; i < pairs.length; i++) {
        const { detectorNode } = pairs[i];
        detectorNode.port.onmessage = (event) => {
          detectorNode.isSilent = event.data.isSilent;
        };
      }
      let msgPromise = waitForMessage(pairs[0].detectorNode);

      console.log("Disabling the tracks for the first detector's stream...");
      const streamToStop = pairs[0].sourceNode.mediaStream;
      streamToStop.getTracks().forEach((track) => (track.enabled = false));

      let msg = await msgPromise;
      assert(
        msg.isSilent,
        `Detector in context with rate ${pairs[0].detectorNode.context.sampleRate} should be silent after its stream tracks were disabled.`
      );
      pairs[0].detectorNode.isSilent = msg.isSilent;

      await delay(
        calculateRequiredDelay(pairs.slice(1).map((p) => p.detectorNode))
      );

      // If MediaStreamTracks are shared across contexts, all detectors should be silent.
      // Otherwise, only the one with the stopped stream should be silent.
      for (let i = 1; i < pairs.length; i++) {
        const { detectorNode } = pairs[i];
        const expectedSilent = !cloneTracks;
        assert(
          detectorNode.isSilent === expectedSilent,
          `Detector in context with rate ${detectorNode.context.sampleRate} expected isSilent=${expectedSilent}, but got isSilent=${detectorNode.isSilent}.`
        );
      }

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testStoppingInputStream(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test stopping input stream silences ${
          cloneTracks ? "nothing" : "all"
        }: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that stopping the original input stream silences nothing or all detectors.

      function stopInputStream() {
        input.dest.stream.getTracks().forEach((track) => track.stop());
      }

      console.log("Stopping the original input stream...");

      // If MediaStreamTracks are shared across contexts, all detectors should become silent.
      // Otherwise, all detectors should still be active since they use cloned tracks.
      if (cloneTracks) {
        for (const { detectorNode } of pairs) {
          detectorNode.port.onmessage = (event) => {
            detectorNode.isSilent = event.data.isSilent;
          };
        }

        stopInputStream();

        await delay(calculateRequiredDelay(pairs.map((p) => p.detectorNode)));
        for (const { detectorNode } of pairs) {
          assert(
            !detectorNode.isSilent,
            `Detector in context with rate ${detectorNode.context.sampleRate} should not be silent after input stream was stopped.`
          );
        }
      } else {
        msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
        stopInputStream();
        msgs = await Promise.all(msgPromises);
        msgs.forEach((msg, i) => {
          assert(
            msg.isSilent,
            `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should be silent after input stream was stopped.`
          );
          pairs[i].detectorNode.isSilent = msg.isSilent;
        });
      }

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testSuspendingInputContextSilencesAll(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test suspending input context silences all: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that suspending the original input context silences all detectors.

      msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      console.log("Suspending the original input context...");
      await input.ctx.suspend();
      msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should be silent after input context was suspended.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }
      input.ctx.close();

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function testClosingInputContextSilencesAll(
      tone,
      srcRate,
      dstRates,
      cloneTracks
    ) {
      console.assert(
        Array.isArray(dstRates) &&
          dstRates.length >= 2 &&
          dstRates.every((r) => Number.isInteger(r) && r > 0) &&
          !dstRates.includes(srcRate),
        "dstRates should be an array of at least two positive integers different from srcRate."
      );
      console.log(
        `Test closing input context silences all: rates=${dstRates}, cloneTracks=${cloneTracks}`
      );

      const input = createSineWaveInput(srcRate, tone);

      // Play the MediaStream in an audio element to indicate that the stream is active.
      const audioEl = document.createElement("audio");
      audioEl.srcObject = input.dest.stream;
      document.body.appendChild(audioEl);
      await audioEl.play();

      // Create multiple MediaStreamAudioSourceNodes with different AudioContext sample rates.
      const pairs = [];
      for (const rate of dstRates) {
        const isolatedStream = new MediaStream(
          cloneTracks
            ? input.dest.stream.getTracks().map((track) => track.clone())
            : input.dest.stream.getTracks()
        );
        pairs.push(
          await createAudioSourceAndSilenceDetector(rate, isolatedStream)
        );
      }

      // 1. Make sure all detectors are not silent after starting the oscillator.

      for (const { detectorNode } of pairs) {
        detectorNode.isSilent = true; // The detector starts as silent.
      }
      let msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      input.osc.start();
      let msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          !msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should not be silent after oscillator starts.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // 2. Verify that closing the original input context silences all detectors.

      msgPromises = pairs.map((p) => waitForMessage(p.detectorNode));
      console.log("Closing the original input context...");
      await input.ctx.close();
      msgs = await Promise.all(msgPromises);
      msgs.forEach((msg, i) => {
        assert(
          msg.isSilent,
          `Detector in context with rate ${pairs[i].detectorNode.context.sampleRate} should be silent after input context was closed.`
        );
        pairs[i].detectorNode.isSilent = msg.isSilent;
      });

      // Clean up AudioContexts.
      for (const { ctx } of pairs) {
        await ctx.close();
      }

      audioEl.pause();
      document.body.removeChild(audioEl);

      console.log("Test completed.");
    }

    async function runAllTests(srcRate, dstRates, cloneTracks) {
      const notes = {
        C4: 261.63,
        D4: 293.66,
        E4: 329.63,
        F4: 349.23,
        G4: 392.0,
        A4: 440.0,
        B4: 493.88,
        C5: 523.25,
      };

      await testClosingOneContextStopsOnlyIt(
        notes.C4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testSuspendingOneContextSilencesOnlyIt(
        notes.D4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testDisconnectingOneSourceSilencesOnlyIt(
        notes.E4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testStoppingOneMediaStream(
        notes.F4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testDisablingOneMediaStream(
        notes.G4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testStoppingInputStream(notes.A4, srcRate, dstRates, cloneTracks);
      await testSuspendingInputContextSilencesAll(
        notes.B4,
        srcRate,
        dstRates,
        cloneTracks
      );
      await testClosingInputContextSilencesAll(
        notes.C5,
        srcRate,
        dstRates,
        cloneTracks
      );
    }

    async function run() {
      const btn = document.querySelector("button");
      btn.textContent = "running...";
      btn.disabled = true;

      const srcRate = 44100;
      const dstRates = [32000, 48000, 96000];
      const trackUsages = { cloned: true, shared: false };

      // Tests with shared MediaStreamTracks.
      runAllTests(srcRate, dstRates, trackUsages.shared);

      // Tests with cloned MediaStreamTracks.
      runAllTests(srcRate, dstRates, trackUsages.cloned);

      btn.disabled = false;
      btn.textContent = "start";
    }

    window.addEventListener("DOMContentLoaded", (event) => {
      const btn = document.createElement("button");
      btn.textContent = "start";
      document.body.appendChild(btn);

      btn.addEventListener("click", () => {
        run();
        btn.disabled = true;
      });
    });
  </script>
  <body>
    <p>
      Testing MediaStreamAudioSourceNode using a MediaStream with a sample rate
      different from the AudioContext.
    </p>
  </body>
</html>
