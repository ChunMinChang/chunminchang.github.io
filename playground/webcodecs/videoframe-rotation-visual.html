<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>VideoFrame Property Visualizer</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }
      .panel {
        border: 1px solid #ccc;
        padding: 15px;
        border-radius: 8px;
        min-width: 320px;
      }
      .panel h2 {
        margin-top: 0;
      }
      label {
        display: block;
        margin-bottom: 5px;
      }
      input[type="text"],
      input[type="number"],
      select,
      button {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        box-sizing: border-box;
      }
      button {
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      button:hover {
        background-color: #0056b3;
      }
      canvas {
        border: 2px solid black;
        background-color: #f0f0f0;
      }
      #webcam-container {
        display: none;
      }
      .note {
        font-size: 0.8em;
        color: #555;
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <div class="panel">
      <h2>1. Select Source</h2>
      <label>
        <input type="radio" name="source" value="default" checked />
        Default RGBA (from Canvas)
      </label>
      <label>
        <input type="radio" name="source" value="buffer" />
        Buffer Source (from raw data)
      </label>
      <div
        id="buffer-options"
        class="note"
        style="display: none; padding-left: 20px"
      >
        <label>
          <input type="radio" name="buffer-format" value="RGBX" checked />
          RGBX
        </label>
        <label>
          <input type="radio" name="buffer-format" value="I420" /> I420
        </label>
        <label>
          <input type="radio" name="buffer-format" value="NV12" /> NV12
        </label>
      </div>
      <label>
        <input type="radio" name="source" value="webcam" />
        Webcam Photo
      </label>
      <label>
        <input type="radio" name="source" value="url" />
        Image from URL
      </label>
      <input
        type="text"
        id="imageUrl"
        placeholder="Enter image URL"
        value="https://upload.wikimedia.org/wikipedia/commons/7/72/Firefox_Browser_%E2%80%93_About-logo%402x.png"
      />
      <div id="webcam-container">
        <video
          id="webcam"
          width="320"
          height="240"
          autoplay
          playsinline
        ></video>
      </div>
    </div>

    <div class="panel">
      <h2>2. Set VideoFrame Properties</h2>
      <label for="rotation">Rotation (degrees):</label>
      <input type="number" id="rotation" value="0" />
      <div class="note">
        Note: An integer representing the rotation (0, 90, 180, or 270) in
        degrees clockwise. Defaults to 0. Arbitrary numbers (including
        negatives) are rounded to the next quarter turn.
      </div>

      <label for="flip">
        <input type="checkbox" id="flip" style="width: auto" />
        Horizontal Flip
      </label>

      <label for="displayWidth">Display Width:</label>
      <input type="number" id="displayWidth" value="320" />

      <label for="displayHeight">Display Height:</label>
      <input type="number" id="displayHeight" value="240" />

      <button id="drawButton">Create and Draw VideoFrame</button>
    </div>

    <div class="panel">
      <h2>3. Result</h2>
      <canvas id="canvas" width="320" height="240"></canvas>
    </div>

    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const sourceRadios = document.querySelectorAll('input[name="source"]');
        const imageUrlInput = document.getElementById("imageUrl");
        const rotationInput = document.getElementById("rotation");
        const flipCheckbox = document.getElementById("flip");
        const displayWidthInput = document.getElementById("displayWidth");
        const displayHeightInput = document.getElementById("displayHeight");
        const drawButton = document.getElementById("drawButton");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const webcamVideo = document.getElementById("webcam");
        const webcamContainer = document.getElementById("webcam-container");
        const bufferOptionsDiv = document.getElementById("buffer-options");
        let imageCapture;

        // --- Source Selection Logic ---
        sourceRadios.forEach((radio) => {
          radio.addEventListener("change", handleSourceChange);
        });

        function handleSourceChange() {
          const selectedSource = document.querySelector(
            'input[name="source"]:checked'
          ).value;

          webcamContainer.style.display =
            selectedSource === "webcam" ? "block" : "none";
          bufferOptionsDiv.style.display =
            selectedSource === "buffer" ? "block" : "none";

          if (selectedSource === "webcam") {
            initWebcam();
          } else {
            stopWebcam();
          }
        }

        async function initWebcam() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: true,
            });
            webcamVideo.srcObject = stream;
            const track = stream.getVideoTracks()[0];
            imageCapture = new ImageCapture(track);
          } catch (err) {
            alert("Could not access webcam: " + err.message);
          }
        }

        function stopWebcam() {
          if (webcamVideo.srcObject) {
            webcamVideo.srcObject.getTracks().forEach((track) => track.stop());
            webcamVideo.srcObject = null;
          }
        }

        function createFourColorCanvas(width, height) {
          const canvas = new OffscreenCanvas(width, height);
          const ctx = canvas.getContext("2d");
          const w = width / 2;
          const h = height / 2;
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = "green";
          ctx.fillRect(w, 0, w, h);
          ctx.fillStyle = "blue";
          ctx.fillRect(0, h, w, h);
          ctx.fillStyle = "yellow";
          ctx.fillRect(w, h, w, h);
          return canvas;
        }

        // --- RGBA to YUV conversion helpers ---
        function rgbaToYuv(r, g, b) {
          const y = 0.299 * r + 0.587 * g + 0.114 * b;
          const u = -0.169 * r - 0.331 * g + 0.5 * b + 128;
          const v = 0.5 * r - 0.419 * g - 0.081 * b + 128;
          return { y, u, v };
        }

        // --- VideoFrame Creation Logic ---
        async function getFrameSource() {
          const selectedSource = document.querySelector(
            'input[name="source"]:checked'
          ).value;

          switch (selectedSource) {
            case "buffer": {
              const format = document.querySelector(
                'input[name="buffer-format"]:checked'
              ).value;
              const width = 320;
              const height = 240;
              const fourColorCanvas = createFourColorCanvas(width, height);
              const rgba = fourColorCanvas
                .getContext("2d")
                .getImageData(0, 0, width, height).data;
              const yuvPlanes = {
                y: new Uint8Array(width * height),
                u: new Uint8Array((width * height) / 4),
                v: new Uint8Array((width * height) / 4),
              };

              // Convert the whole frame to YUV planes first
              for (let j = 0; j < height; j++) {
                for (let i = 0; i < width; i++) {
                  const rgbaIndex = (j * width + i) * 4;
                  const yuv = rgbaToYuv(
                    rgba[rgbaIndex],
                    rgba[rgbaIndex + 1],
                    rgba[rgbaIndex + 2]
                  );
                  yuvPlanes.y[j * width + i] = yuv.y;
                  if (j % 2 === 0 && i % 2 === 0) {
                    const uvIndex = (j / 2) * (width / 2) + i / 2;
                    yuvPlanes.u[uvIndex] = yuv.u;
                    yuvPlanes.v[uvIndex] = yuv.v;
                  }
                }
              }

              if (format === "RGBX") {
                return {
                  data: rgba,
                  init: {
                    format: "RGBX",
                    codedWidth: width,
                    codedHeight: height,
                    layout: [{ offset: 0, stride: width * 4 }],
                  },
                };
              } else if (format === "I420") {
                const i420Data = new Uint8Array(width * height * 1.5);
                i420Data.set(yuvPlanes.y, 0);
                i420Data.set(yuvPlanes.u, width * height);
                i420Data.set(yuvPlanes.v, width * height * 1.25);
                return {
                  data: i420Data,
                  init: {
                    format: "I420",
                    codedWidth: width,
                    codedHeight: height,
                    layout: [
                      { offset: 0, stride: width }, // Y
                      { offset: width * height, stride: width / 2 }, // U
                      { offset: width * height * 1.25, stride: width / 2 }, // V
                    ],
                  },
                };
              } else if (format === "NV12") {
                const nv12Data = new Uint8Array(width * height * 1.5);
                nv12Data.set(yuvPlanes.y, 0);
                const uvPlaneOffset = width * height;
                for (let i = 0; i < yuvPlanes.u.length; i++) {
                  nv12Data[uvPlaneOffset + i * 2] = yuvPlanes.u[i];
                  nv12Data[uvPlaneOffset + i * 2 + 1] = yuvPlanes.v[i];
                }
                return {
                  data: nv12Data,
                  init: {
                    format: "NV12",
                    codedWidth: width,
                    codedHeight: height,
                    layout: [
                      { offset: 0, stride: width }, // Y
                      { offset: width * height, stride: width }, // UV
                    ],
                  },
                };
              }
              return null;
            }
            case "webcam":
              if (!imageCapture) {
                alert("Webcam not initialized.");
                return null;
              }
              return await imageCapture.grabFrame();
            case "url":
              try {
                const response = await fetch(imageUrlInput.value, {
                  mode: "cors",
                });
                const blob = await response.blob();
                return await createImageBitmap(blob);
              } catch (err) {
                alert("Failed to load image from URL: " + err.message);
                return null;
              }
            case "default":
            default:
              return createFourColorCanvas(320, 240);
          }
        }

        // --- Main Drawing Logic ---
        drawButton.addEventListener("click", async () => {
          const frameSource = await getFrameSource();
          if (!frameSource) return;

          const frameOptions = {
            rotation: parseFloat(rotationInput.value),
            flip: flipCheckbox.checked,
            displayWidth: parseInt(displayWidthInput.value, 10),
            displayHeight: parseInt(displayHeightInput.value, 10),
            timestamp: 0,
          };

          let videoFrame;
          try {
            // Handle both data-based and source-based frame creation
            if (frameSource.data && frameSource.init) {
              videoFrame = new VideoFrame(frameSource.data, {
                ...frameSource.init,
                ...frameOptions,
              });
            } else {
              videoFrame = new VideoFrame(frameSource, frameOptions);
            }
          } catch (err) {
            alert(
              "Error creating VideoFrame: " +
                err.message +
                "\n\nNote: The 'rotation' property must be 0, 90, 180, or 270."
            );
            return;
          }

          // Adjust canvas size to match the frame's display dimensions
          canvas.width = videoFrame.displayWidth;
          canvas.height = videoFrame.displayHeight;

          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();

          ctx.drawImage(
            videoFrame,
            0,
            0,
            videoFrame.displayWidth,
            videoFrame.displayHeight
          );

          ctx.restore();

          console.log("Drew VideoFrame with options:", frameOptions);

          // Close the frame to free up resources
          videoFrame.close();
        });
      });
    </script>
  </body>
</html>
